// Each new term in the Fibonacci sequence is generated by adding the previous
// two terms. By starting with 1 and 2, the first 10 terms will be:
//
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
//
// By considering the terms in the Fibonacci sequence whose values
// do not exceed four million, find the sum of the even-valued terms.

// memoizing reduces the time complexity to O(n)
// basic recursive Fibonacci solution for n items
// const fibonacciSequence = (n, memo) => {
//   memo = memo || {};
//   if ( n < 0 ) {
//     return null;
//   }
//   if ( n <= 1 ) {
//     return 1;
//   }
//   return memo[n] = fibonacciSequence(n-1, memo) + fibonacciSequence(n-2, memo);
// };

// iterative solution for a fixed n
// const fibonacciIterative = (n) => {
//   let total = [];
//   let a = 0,
//       b = 1;
//   for (var i = 1; i <= n; i++) {
//     let c = a + b;
//     a = b;
//     b = c;
//     total.push(b)
//   }
//   return total;
// };

const fibonacciIterativeSum = () => {
  let total = 0,
    tempTotal = 0,
    a = 0,
    b = 1;
  while (total < 4000000) {
    let c = a + b;
    a = b;
    b = c;
    if ( c % 2 === 0 ) {
      tempTotal = total;
      total += c;
      if (total > 4000000) {
        break;
      }
    }
  }
  return tempTotal;
};

console.log(fibonacciIterativeSum());

const fibonacciRecusiveSum = () => {
  const memo = {};
  const recurseFib = (n) => {
    let value = null;

    if (memo[n]) {
      value = memo[n];
    } else {
      if ( n === 0 || n === 1 ) {
        value = 1;
      } else {
        value = recurseFib(n-1) + recurseFib(n-2);
        memo[n] = value;
      }
    }

    return value;
  };
  return recurseFib(10);
};

console.log(fibonacciRecusiveSum());
